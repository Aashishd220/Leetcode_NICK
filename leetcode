1. 118. Pascal's Triangle
    Taking sum from previous rows.
    Do Again.
    
2. 217. Contains Duplicate
    Easy Peasy!!!
  
3. 206. Reverse Linked List
    prev, curr, next. 
    Easy think!!
    
4. 167. Two Sum II 
    Easy Peasy!!
    
5. 234. Palindrome Linked List
    Find the middle(fast!=null && fast.next!=null && fast.next.next!=null)
    from middle.next reverse the linked list
    and compare.
    
6. 590. N-ary Tree Postorder Traversal
    Input: root = [1,null,3,2,4,null,5,6]
    Output: [5,6,3,2,4,1]
    
   pollLast use to get the last element from stack
   and addFirst used to add the element in the last in the linkedList.
   
   
7. 94. Binary Tree Inorder Traversal
    Inorder- Left Root Right
    use 2 loops - first to check the stack size and curr node
                - second to reach to left most node.
                
            
8. 328. Odd Even Linked List
    Input: 2->1->3->5->6->4->7->NULL
    Output: 2->3->6->7->1->5->4->NULL
    
   assign odd=head and even=head.next;
   Run while(even!=null && even.next!=null)
   Think about the logic!! 
   Not very difficult.
   
 9. 709. To Lower Case
 Input: "Hello"
Output: "hello"
Easy peasy
65-90 'A' 97-122 'a'
  ch=(char)(ch+32);
  
  
10.  7. Reverse Integer
    take rev as long
    return flag==true?(int)-rev:(int)rev;
    
 11. 9. Palindrome Number
 Easy Peasy
 
 12. 844. Backspace String Compare
    Input: S = "ab#c", T = "ad#c"
    Output: true
    Explanation: Both S and T become "ac".
    
    You can use stack and think about the answer.
    or use 2 pointers.
    Do it again with both methods.
    
 13. 917. Reverse Only Letters
 Input: "ab-cd"
Output: "dc-ba"
    Use stack!! Easy
    
    
 14. 141. Linked List Cycle
    fast!=null && fast.next!=null
    for even and odd number of nodes respec.
    
 15. 344. Reverse String
    Input: ["h","e","l","l","o"]
    Output: ["o","l","l","e","h"]
    
    Easy Peasy!!!
    
    
16.125. Valid Palindrome
Input: "A man, a plan, a canal: Panama"
Output: true

2 solutions. Think and implement both.
Easy.


17. 876. Middle of the Linked List
    easy peasy!!!
    
18. 21. Merge Two Sorted Lists
Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4
Easy Peasy!!! use merge sort

19. 657. Robot Return to Origin 
    Input: "UD"
    Output: true
    Easy Peasy!!! Do it by yourself!!
    
    
20. 841. Keys and Rooms
Input: [[1],[2],[3],[]]
Output: true
Explanation:  
We start in room 0, and pick up key 1.
We then go to room 1, and pick up key 2.
We then go to room 2, and pick up key 3.
We then go to room 3.  Since we were able to go to every room, we return true.

DFS Problem- Use Stack. Do it once again.

21. 977. Squares of a Sorted Array
    Input: [-4,-1,0,3,10]
    Output: [0,1,9,16,100]
    
    Do it in N time using 2 pointers.
    
 22. 16. 3Sum Closest
    Do it again.
    
 23.846. Hand of Straights 
 Input: hand = [1,2,3,6,2,3,4,7,8], W = 3
Output: true
Explanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8].

Use Priority Queue as minHeap. First, add the elements in the minHeap, now minHeap will be  [1,2,3,6,2,3,4,7,8] and 
when you remove the elements from the minHeap the output will be 1,2,2,3,3,4,6,7,8
Now think about the logic 
do it again!!!!!

24. 771. Jewels and Stones
Input: J = "aA", S = "aAAbbbb"
Output: 3
Easy Peasy!!!
